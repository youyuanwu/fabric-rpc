#include "printer.hpp"

#include <google/protobuf/compiler/code_generator.h>
#include <google/protobuf/descriptor.h>

#include <fstream>
#include <vector>

namespace pb = google::protobuf;

// helper functions
std::string getProtoNameNoExt(std::string const &filename) {
  std::string proto_name = filename;
  std::size_t dot = proto_name.rfind(".proto");
  if (dot != std::string::npos) {
    proto_name.resize(dot);
  }
  return proto_name;
}

// generates include etc for header file.
class pbGenMetaHeader {
public:
  pbGenMetaHeader(const pb::FileDescriptor *file) : file_(file) {}

  std::string GenerateContent() {

    std::map<std::string, std::string> vars;
    vars["filename"] = file_->name();
    vars["filename_base"] = getProtoNameNoExt(file_->name());
    vars["message_header_ext"] = ".pb.h";

    std::string output;
    printer p(output);
    p.AddLn("// Generated by fabric_rpc2_cpp_plugin. Do not Edit.");

    p.AddLn(vars, "// source: $filename$");

    p.AddLn(vars, "#pragma once");

    // protobuf header
    p.AddLn(vars, "#include \"$filename_base$$message_header_ext$\"");

    // fabric rpc required headers
    p.Add("#include \"fabrictransport_.h\"\n"
          "#include \"fabricrpc/fabricrpc2.hpp\"\n");

    return p.GetOutput();
  }

private:
  const pb::FileDescriptor *file_;
};

// generator for a single pb file. For client header.
class pbGenClientHeader {
public:
  pbGenClientHeader(const pb::FileDescriptor *file) : file_(file) {}

  // client code generation block
  void
  PrintHeaderClientMethodSync(printer &p,
                              const google::protobuf::MethodDescriptor *method,
                              std::map<std::string, std::string> &vars) {
    vars["Method"] = method->name();
    vars["Request"] = method->input_type()->name();
    vars["Response"] = method->output_type()->name();
    bool no_streaming =
        !(method->client_streaming() || method->server_streaming());
    if (no_streaming) {
      p.AddLn(
          vars,
          "// handler void(ec, absl::Status)\n"
          "template <typename Token>\n"
          "auto SayHello($Request$ *request,\n"
          "/*out*/$Response$ *reply, Token &&token) {\n"
          "static const std::string url = \"/$Package$$Service$/$Method$\";\n"
          "return conn_.async_send(url, request, reply, std::move(token));\n"
          "}");
    } else {
      p.AddLn("// Streamingfor method $Method$ request $Request$ response "
              "$Response$ not supported ");
    }
  }

  void
  PrintHeaderClientService(printer &p,
                           const google::protobuf::ServiceDescriptor *service,
                           std::map<std::string, std::string> vars) {
    vars["Service"] = service->name();
    p.Add(vars, "template <typename Executor = net::any_io_executor> class "
                "$Service$Client{\n"
                "public:\n");
    p.Indent();
    p.AddLn("typedef Executor executor_type;");
    p.AddLn(vars, "$Service$Client(fabricrpc::rpc_client<executor_type> &conn) "
                  ": conn_(conn) {}");
    for (int i = 0; i < service->method_count(); ++i) {
      PrintHeaderClientMethodSync(p, service->method(i), vars);
    }
    p.Outdent();
    p.AddLn("private:\n");
    p.Indent();
    p.Add("fabricrpc::rpc_client<executor_type> &conn_;");
    p.Outdent();
    p.Add("};\n");
  }

  std::string GenerateContent() {
    std::string output;
    printer p(output);
    std::map<std::string, std::string> vars;

    vars["Package"] = file_->package();
    if (!file_->package().empty()) {
      vars["Package"].append(".");
    }

    vars["Namespace"] = file_->package();
    if (vars["Namespace"].empty()) {
      vars["Namespace"] = "fabricrpc2";
    }

    p.AddLn(vars, "// Client code");

    p.AddLn(vars, "namespace $Namespace$ {");

    p.AddLn("namespace net = boost::asio;");

    for (int i = 0; i < file_->service_count(); ++i) {
      PrintHeaderClientService(p, file_->service(i), vars);
    }

    // create the request handler

    p.AddLn(vars, "} // namespace $Namespace$");
    return p.GetOutput();
  }

private:
  const pb::FileDescriptor *file_;
};

// generate client cc
class pbGenClientCC {
public:
  pbGenClientCC(const pb::FileDescriptor *file) : file_(file) {}

  std::string GenerateContent() { return ""; }

private:
  const pb::FileDescriptor *file_;
};

class pbGenServerHeader {
public:
  pbGenServerHeader(const pb::FileDescriptor *file) : file_(file) {}

  void
  PrintHeaderServerMethodSync(printer &p,
                              const google::protobuf::MethodDescriptor *method,
                              std::map<std::string, std::string> &vars) {
    vars["Method"] = method->name();
    vars["Request"] = method->input_type()->name();
    vars["Response"] = method->output_type()->name();
    bool no_streaming =
        !(method->client_streaming() || method->server_streaming());
    if (no_streaming) {
      p.AddLn("virtual net::awaitable<absl::Status> "
              "SayHello(helloworld::FabricRequest *request,"
              "helloworld::FabricResponse *resp) = 0;");
    } else {
      p.AddLn("// Streaming for method $Method$ request $Request$ response "
              "$Response$ not supported ");
    }
  }

  void PrintHeaderService(printer &p,
                          const google::protobuf::ServiceDescriptor *service,
                          std::map<std::string, std::string> vars) {
    vars["Service"] = service->name();

    p.Add(vars, "class $Service$ : public fabricrpc::service {\n"
                "  public:\n");
    p.Indent();

    // Service metadata
    p.Add(vars, "const std::string_view name() override { return "
                "\"helloworld.FabricHello\"; }\n");

    // routing
    p.Add(vars, "net::awaitable<absl::Status> execute(const std::string &url,\n"
                "const std::string_view req,\n"
                "std::string *resp) override {\n");
    p.Indent();
    p.AddLn(vars, "absl::Status st;");
    for (int i = 0; i < service->method_count(); ++i) {
      const google::protobuf::MethodDescriptor *method = service->method(i);
      vars["Method"] = method->name();
      vars["Request"] = method->input_type()->name();
      vars["Response"] = method->output_type()->name();
      if (i != 0) {
        p.Add("else ");
      }
      p.Add(vars, "if (url == \"/$Package$$Service$/$Method$\") {\n");
      p.Indent();
      p.Add(vars, "st = co_await fabricrpc::codegen_handler_helper<\n"
                  "$Request$, $Response$,\n"
                  "decltype(&$Service$::$Method$), decltype(this)>(\n"
                  "req, resp, &$Service$::$Method$, this);\n");
      p.Outdent();
      p.AddLn("}"); // close if
    }
    p.Add("else {\n"
          "  st = absl::UnimplementedError(absl::StrCat(\"url: \", url, \" not "
          "found\"));\n"
          "}\n");
    p.AddLn("co_return st;");
    p.Outdent();
    p.AddLn("}"); // close execute

    // methods that user needs to implement
    for (int i = 0; i < service->method_count(); ++i) {
      PrintHeaderServerMethodSync(p, service->method(i), vars);
    }

    p.Outdent();
    p.AddLn("};"); // close class
  }

  std::string GenerateContent() {
    std::string output;
    printer p(output);
    std::map<std::string, std::string> vars;

    vars["Package"] = file_->package();
    if (!file_->package().empty()) {
      vars["Package"].append(".");
    }

    vars["Namespace"] = file_->package();
    if (vars["Namespace"].empty()) {
      vars["Namespace"] = "fabricrpc2";
    }

    p.AddLn(vars, "// Server code");

    p.AddLn(vars, "namespace $Namespace$ {");

    p.AddLn("namespace net = boost::asio;");

    for (int i = 0; i < file_->service_count(); ++i) {
      PrintHeaderService(p, file_->service(i), vars);
    }

    // create the request handler

    p.AddLn(vars, "} // namespace $Namespace$");
    return p.GetOutput();
  }

private:
  const pb::FileDescriptor *file_;
};

class pbGenServerCC {
public:
  pbGenServerCC(const pb::FileDescriptor *file) : file_(file) {}

  std::string GenerateContent() { return ""; }

private:
  const pb::FileDescriptor *file_;
};

// this generator implements protobufs
// <google/protobuf/compiler/code_generator.h> interface

class CodeGenerator : public google::protobuf::compiler::CodeGenerator {
public:
  bool Generate(const pb::FileDescriptor *file, const std::string &parameter,
                google::protobuf::compiler::GeneratorContext *generator_context,
                std::string *error) const override {
    // usually input file name is myapp.proto
    // out file should be myapp.fabricrpc.h
    // and myapp.fabricrpc.cc
    std::string proto_name = getProtoNameNoExt(file->name());
    // generate header
    std::string out_header_file_name = proto_name + ".fabricrpc2.h";
    std::ofstream o_header(out_header_file_name.c_str());

    {
      pbGenMetaHeader gen(file);
      o_header << gen.GenerateContent();
    }
    {
      pbGenClientHeader gen(file);
      o_header << gen.GenerateContent();
    }
    {
      pbGenServerHeader gen(file);
      o_header << gen.GenerateContent();
    }

    o_header.close();

    // generate cc
    std::string out_cc_file_name = proto_name + ".fabricrpc2.cc";
    std::ofstream o_cc(out_cc_file_name.c_str());

    {
      pbGenClientCC gen(file);
      o_cc << gen.GenerateContent();
    }
    {
      pbGenServerCC gen(file);
      o_cc << gen.GenerateContent();
    }

    o_cc.close();

    return true;
  }
};